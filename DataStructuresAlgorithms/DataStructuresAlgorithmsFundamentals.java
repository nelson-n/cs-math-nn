
//------------------------------------------------------------------------------
// Data Structures & Algorithms Fundamentals
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Overview of Data Structures
//------------------------------------------------------------------------------

/* 

Overview of Data Structures
- Basic Types
    - int, long, double, character, etc.
- Struct
    - Grouping of objects of different data types.
    - Stored contiguously in memory.
    - Cannot grow or shrink.
    - Used to group a set of known attributes.
    - Stored internally as bits arranged in a specific way.
- Arrays
    - Grouping of object of homogenous data type.
    - Stored contiguously in memory (each elements is stored immediately after
    the previous element).
    - Cannot grow or shrink.
    - Fast random access.
    - Slow inserts as inserting requires making a new array.
    - Slow deletes, also requires making a new array.
    - Good for problems that require many random reads.
- Lists
    - Stored non-contiguously in memory (items are stored randomly in memory)
    - Slow random access because data is stored non-contiguously.
    - Fast inserts and deletes because there is no need to shift all the elements
    after and before the place you are inserting and deleting from (another result
    of having non-contiguous representation in memory).
    - Good for problems that require lots of inserts and deletes.
- Graphs
    - General structure used in many applications.
- Classes / Fields
    - Classes themselves can be thought of as data structures that contain fields 
    which are also data.
    - With arrays it does not matter if it has 10 elements or 10m elements, accessing
    members of the array takes the same amount of time. However, inserts and deleters
    are very slow.

Objectives of Data Structures
- Efficiency
    - Algorithms should perform quickly for their intended task.
- Abstraction
    - Interfaces should be clearly and simply defined, complexity of how operations
    are actually carried out should be hidden under the surface.
- Reusability
    - The data structure should work regardless of the underlying data type.
    - Generic implementation allows one implementation to be used with multiple
    types.

*/

//------------------------------------------------------------------------------
// Overview of Algorithms
//------------------------------------------------------------------------------

/*

Overview of Algorithms
- Algorithms are at their core functions.
- The three objective of algorithms are the same as data structures.
    - Efficiency
    - Abstraction
    - Reusability

*/

//------------------------------------------------------------------------------
// Structure of the JVM
//------------------------------------------------------------------------------

/* 

Structure of the JVM
- Knowledge of how the JVM runs helps when trying to write efficient code. It is
useful to know where objects are placed in memory in order to estimate when one
might run out of memory.

- Class files (compiled Java programs) get loaded into memory by the Class Loader of
the JVM. This puts the program in memory.

- There are then 4 main areas that contain the compiled code and the memory it requires.

    - Method Area = The compiled code itself, loaded into memory as bytecode. Remains
    static as the program is running. All threads share one method area.

    - Heap = Where objects created using `new` are placed. All threads share one heap.

    - Stack = Where objects created inside of the function are placed. For example,
    a local int variable or a parameter of type int. Each thread has its own stack.

    - Registers = Holds that data that is generated by the function. If the program
    specifies the operation A + B, then value of A and B are loaded into the 
    registers so that the operation can be performed. Each thread has its own 
    registers.

    - Native Method Stacks = Hold the Java native methods (basic and often used
    methods) in binary. 

- The Execution Engine controls the execution of the methods as they run and it 
interacts with all of the parts of memory of the program.

- Bytecode (such as methods) and dynamically created objects (objects that get
stored on the heap) are shared across computer threads.
    - Because objects on the heap can be changed, if you have multiple threads
    changing objects on the heap, then other threads will see those objects
    being changed.
    - This is where it is important to write code that is thread safe with 
    locked objects.

- Each thread gets its own stack (its own little segment of memory).
    - Each function call pushes a new stack frame onto a thread's stack. 
    - Stack frames hold references, primitive values, and space for temporary
    values.
    - Any parameters and information necessary for running the function get stored
    on each stack. This is important for recursion where you have a function 
    calling itself, as it keeps calling itself the stack will keep growing as 
    each function call opens up a new stack. Ultimately you will run out of 
    stack space and get a stack overflow exception.
    - This also means that if you have a local variable in a function, each thread
    will have a copy of this local variable (only objects that are dynamically 
    allocated and placed in the heap are shared across threads).

*\

//------------------------------------------------------------------------------
// Primitive vs. Reference Types
//------------------------------------------------------------------------------

/* 

Primitive vs. Reference Data Types
- Primitive types include boolean, float, double, byte, short, int, long, char.
- When declared in a function they go directly on to the stack.

- Reference types point to an objece. A reference variable is itself a
primitive type, but the object it refers to is not.

- Whenever an object is created, the object itself (i.e. new object of the class
Person) is stored in the heap, but stack memory contains the reference to it.

- You can define a class (reference type) that contains integers (primitives), 
because the class is a reference type it is placed on the heap, and the integers
within that class are also placed on the heap.
    - The ultimate determinate of where an object is placed is the top most 
    container of the data.

*/

// Primitives vs. Reference Types Example

// Person class.
public class Person {

    // When Person is inited, it will sit out on the heap and there will be a 
    // reference to a string (name) that will also be on the heap.
    private String name; 

    // int which is primitive occurs inline inside of the Person object so it 
    // is also a reference and is on the heap.
    private int age;

    // friend field references the Person object, the person referred to will
    // be stored on heap
    private Person friend; 

    // Init of the object.
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person getFriend() {
        return friend;
    }

    // Set a friend by passing a reference to another friend.
    public void setFriend(Person friend) {
        this.friend = friend;
    }
}

// Example class that calls the person class.

// The class itself gets dispatched to a new stack.
public class Main {
    public static void main(String[] args) {

        // String[] args which is an array of strings goes on the heap as arguments
        // necessary for the function to run always go on the heap.

        // The instantiated objects (sam, rhonda) are reference objects that 
        // exist on the stack, but they point to a name(string) and age (int)
        // which are on the heap.
        Person sam = new Person("Sam", 12);
        Person rhonda = new Person("Rhonda", 12);

        // This reference to the object rhonda goes on the heap.
        sam.setFriend(rhonda);

        // int primitive goes on the stack.
        int tenYears = 10;

        // temporary result of addition stored on stack
        sam.setAge(sam.getAge() + tenYears);
    }
}

// References (sam, rhonda) are pointers to the address of some other object.

//------------------------------------------------------------------------------
// Function Call Details
//------------------------------------------------------------------------------

















