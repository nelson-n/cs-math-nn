
//------------------------------------------------------------------------------
// Data Structures & Algorithms Fundamentals
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Overview of Data Structures
//------------------------------------------------------------------------------

/* 

Overview of Data Structures
- Basic Types
    - int, long, double, character, etc.
- Struct
    - Grouping of objects of different data types.
    - Stored contiguously in memory.
    - Cannot grow or shrink.
    - Used to group a set of known attributes.
    - Stored internally as bits arranged in a specific way.
- Arrays
    - Grouping of object of homogenous data type.
    - Stored contiguously in memory (each elements is stored immediately after
    the previous element).
    - Cannot grow or shrink.
    - Fast random access.
    - Slow inserts as inserting requires making a new array.
    - Slow deletes, also requires making a new array.
    - Good for problems that require many random reads.
- Lists
    - Stored non-contiguously in memory (items are stored randomly in memory)
    - Slow random access because data is stored non-contiguously.
    - Fast inserts and deletes because there is no need to shift all the elements
    after and before the place you are inserting and deleting from (another result
    of having non-contiguous representation in memory).
    - Good for problems that require lots of inserts and deletes.
- Graphs
    - General structure used in many applications.
- Classes / Fields
    - Classes themselves can be thought of as data structures that contain fields 
    which are also data.
    - With arrays it does not matter if it has 10 elements or 10m elements, accessing
    members of the array takes the same amount of time. However, inserts and deleters
    are very slow.

Objectives of Data Structures
- Efficiency
    - Algorithms should perform quickly for their intended task.
- Abstraction
    - Interfaces should be clearly and simply defined, complexity of how operations
    are actually carried out should be hidden under the surface.
- Reusability
    - The data structure should work regardless of the underlying data type.
    - Generic implementation allows one implementation to be used with multiple
    types.

*/

//------------------------------------------------------------------------------
// Overview of Algorithms
//------------------------------------------------------------------------------

/*

Overview of Algorithms
- Algorithms are at their core functions.
- The three objective of algorithms are the same as data structures.
    - Efficiency
    - Abstraction
    - Reusability

Structure of the JVM
- Knowledge of how the JVM runs helps when trying to write efficient code. It is
useful to know where objects are placed in memory in order to estimate when one
might run out of memory.

- Class files (compiled Java programs) get loaded into memory by the Class Loader of
the JVM. This puts the program in memory.

- There are then 4 main areas that contain the compiled code and the memory it requires.

    - Method Area = The compiled code itself, loaded into memory as bytecode. Remains
    static as the program is running. All threads share one method area.

    - Heap = Where objects created using `new` are placed. All threads share one heap.

    - Stack = Where objects created inside of the function are placed. For example,
    a local int variable or a parameter of type int. Each thread has its own stack.

    - Registers = Holds that data that is generated by the function. If the program
    specifies the operation A + B, then value of A and B are loaded into the 
    registers so that the operation can be performed. Each thread has its own 
    registers.

    - Native Method Stacks = Hold the Java native methods (basic and often used
    methods) in binary. 

- The Execution Engine controls the execution of the methods as they run and it 
interacts with all of the parts of memory of the program.

- Bytecode (such as methods) and dynamically created objects (objects that get
stored on the heap) are shared across computer threads.
    - Because objects on the heap can be changed, if you have multiple threads
    changing objects on the heap, then other threads will see those objects
    being changed.
    - This is where it is important to write code that is thread safe with 
    locked objectgs.

- Each thread gets its own stack (its own little segment of memory).
    - Each function call pushes a new stack frame onto a thread's stack. 
    - Stack frames hold references, primitive values, and space for temporary
    values.
    - Any parameters and information necessary for running the function get stored
    on each stack. This is important for recursion where you have a function 
    calling itself, as it keeps calling itself the stack will keep growing as 
    each function call opens up a new stack. Ultimately you will run out of 
    stack space and get a stack overflow exception.
    - This also means that if you have a local variable in a function, each thread
    will have a copy of this local variable (only objects that are dynamically 
    allocated and placed in the heap are shared across threads).

Primitive vs. Reference Data Types



 */


